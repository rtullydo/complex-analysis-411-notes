<?xml version="1.0" encoding="UTF-8" ?>

<pretext xmlns:xi="http://www.w3.org/2001/XInclude">

    <docinfo>
        <macros>
        \DeclareMathOperator{\RE}{Re}
          \DeclareMathOperator{\IM}{Im}
          \DeclareMathOperator{\ess}{ess}
          \DeclareMathOperator{\intr}{int}
          \DeclareMathOperator{\dist}{dist}
          \DeclareMathOperator{\dom}{dom}
          \DeclareMathOperator{\diag}{diag}
          \DeclareMathOperator{\span}{span}
          \DeclareMathOperator{\null}{null}
          \DeclareMathOperator{\rank}{rank}
          \DeclareMathOperator{\col}{col}
          \DeclareMathOperator{\cl}{cl}
          \DeclareMathOperator{\row}{row}
          \DeclareMathOperator{\proj}{proj}
          \DeclareMathOperator{\ball}{ball}
          \DeclareMathOperator\re{\mathrm {Re~}}
          \DeclareMathOperator\im{\mathrm {Im~}}
          %\newcommand\half{\tfrac 12}
          \newcommand\dd{\mathrm d}
          \newcommand{\eps}{\varepsilon}
          \newcommand{\To}{\longrightarrow}
          \newcommand{\hilbert}{\mathcal{H}}
          \newcommand{\s}{\mathcal{S}_2}
          \newcommand{\A}{\mathcal{A}}
          \newcommand\h{\mathcal{H}}
          \newcommand{\J}{\mathcal{J}}
          \newcommand{\M}{\mathcal{M}}
          \newcommand{\F}{\mathbb{F}}
          \newcommand{\K}{\mathcal{K}}
          \newcommand{\N}{\mathcal{N}}
          \newcommand{\T}{\mathbb{T}}
          \newcommand{\W}{\mathcal{W}}
          \newcommand{\X}{\mathcal{X}}
          \newcommand{\Y}{\mathcal{Y}}
          \newcommand{\D}{\mathbb{D}}
          \newcommand{\C}{\mathbb{C}}
          \newcommand{\BOP}{\mathbf{B}}
          \newcommand{\Z}{\mathbb{Z}}
          \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
          \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
          \newcommand{\pick}{\mathcal{P}_2}
          \newcommand{\schur}{\mathcal{S}_2}
          \newcommand{\R}{\mathbb{R}}
          \newcommand{\Complex}{\mathbb{C}}
          \newcommand{\Field}{\mathbb{F}}
          \newcommand{\RPlus}{\Real^{+}}
          \newcommand{\Polar}{\mathcal{P}_{\s}}
          \newcommand{\Poly}{\mathcal{P}(E)}
          \newcommand{\EssD}{\mathcal{D}}
          \newcommand{\Lop}{\mathcal{L}}
          \newcommand{\cc}[1]{\overline{#1}}
          \newcommand{\abs}[1]{\left\vert#1\right\vert}
          \newcommand{\set}[1]{\left\{#1\right\}}
          \newcommand{\seq}[1]{\left\lt#1\right>}
          \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
          \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}
          \newcommand{\tr}{\operatorname{tr}}
          \newcommand{\ran}[1]{\operatorname{ran}#1}
          \newcommand{\nt}{\stackrel{\mathrm {nt}}{\to}}
          \newcommand{\pnt}{\xrightarrow{pnt}}
          \newcommand{\ip}[2]{\left\langle #1, #2 \right\rangle}
          \newcommand{\ad}{^\ast}
          \newcommand{\inv}{^{-1}}
          \newcommand{\adinv}{^{\ast -1}}
          \newcommand{\invad}{^{-1 \ast}}
          \newcommand\Pick{\mathcal P}
          \newcommand\Ha{\mathbb{H}}
          \newcommand{\HH}{\Ha\times\Ha}
          \newcommand\Htau{\mathbb{H}(\tau)}
          \newcommand{\vp}{\varphi}
          \newcommand{\ph}{\varphi}
          \newcommand\al{\alpha}
          \newcommand\ga{\gamma}
          \newcommand\de{\delta}
          \newcommand\ep{\varepsilon}
          \newcommand\la{\lambda}
          \newcommand\up{\upsilon}
          \newcommand\si{\sigma}
          \newcommand\beq{\begin{equation}}
          \newcommand\ds{\displaystyle}
          \newcommand\eeq{\end{equation}}
          \newcommand\df{\stackrel{\rm def}{=}}
          \newcommand\ii{\mathrm i}
          \newcommand\net[1]{\langle #1 \rangle}
          \newcommand{\vectwo}[2]
          {
             \begin{pmatrix} #1 \\ #2 \end{pmatrix}
          }
          \newcommand{\vecthree}[3]
          {
             \begin{pmatrix} #1 \\ #2 \\ #3 \end{pmatrix}
          }
          \newcommand\blue{\color{blue}}
          \newcommand\black{\color{black}}
          \newcommand\red{\color{red}}
          %\newcommand\red{\color{black}}
          \newcommand\nn{\nonumber}
          \newcommand\bbm{\begin{bmatrix}}
          \newcommand\ebm{\end{bmatrix}}
          \newcommand\bpm{\begin{pmatrix}}
          \newcommand\epm{\end{pmatrix}}
          \numberwithin{equation}{section}
          \newcommand\nin{\noindent}
          \newcommand{\nCr}[2]{\,_{#1}C_{#2}} % nCr
          \newcommand{\vec}[1]{{\bf #1}}
          \newcommand{\ps}{\displaystyle \sum_{n=0}^\infty a_n x^n}
          \newcommand{\psg}{\displaystyle \sum_{n=0}^\infty b_n x^n}
          \newcommand{\hz}{\,\mathrm{Hz}}
          \newcommand{\d}{^\prime}
        </macros>
    </docinfo>

<book xml:id="comp411">
    <title>Notes on complex analysis</title>
    <frontmatter>

        <titlepage>
            <author>
              <personname>Ryan Tully-Doyle</personname>
              <institution>Cal Poly, SLO</institution>
            </author>
            <date><today /></date>
        </titlepage>
    </frontmatter>


    <chapter><title>Conformal maps and linear fractional transformations</title>
    <section>
        <title>Conformal maps</title>
        <p>Certain functions behave like little rigid rotations locally.
            <definition>
                A function <m>f: A \to B</m> is called <term>conformal</term> if for each <m>z_0 \in A</m>, <m>f</m> rotates tangent vectors to curves passing through <m>z_0</m> by a fixed angle <m>\theta</m> and stretches tangent vectors to curves by a fixed factor <m>r</m>.
            </definition>
        </p>

        <p>There is a close connection between analytic maps and conformal maps.</p>
        <theorem>
            <p>Let <m>f: A \to B</m> be analytic and let <m>f^\prime(z_0) \neq 0</m> for all <m>z_0 \in A</m>. Then <m>f</m> is conformal.</p>.
        </theorem>
        <p>This is pretty straighforward to see via the chain rule. Let <m>\gamma(t)</m> be a (differentiable) path contained in <m>A</m> with <m>\gamma(0) = z_0</m>. Let <m>\sigma(t)</m> be the image of <m>\gamma</m> under <m>f</m> defined by <m>\sigma(t) = f(\gamma(t))</m>. Then the chain rule gives
        <me>
            \sigma\d(t) = f\d(\gamma(t)) \cdot \gamma\d(t)
        </me>
        which in turn gives
        <me>
            \sigma\d(0) = f\d(z_0) \cdot \gamma\d(0).
        </me>
        That is, if <m>f\d(z_0) = r e^{i \theta}</m> the image of the derivative of any curve <m>\gamma</m> through <m>z_0</m> is rotated by <m>\theta</m> and stretched by <m>r</m>.
        </p>

        <p>Note that the condition that <m>f\d(z_0) \neq 0</m> is necessary. For one, it obviously covers up the relationship between a curve and its image in the relation above. But the problem is deeper. Consider the function <m>f(z) = z^2</m>. Consider the lines that run along the <m>x-</m> and <m>y-</m>axis. These lines cross at a right angle at <m>z = 0</m>, but since both lines are mapped to the real axis under <m>f</m>, their images intersect at an angle of <m>\pi</m> radians. For this reason, points at which <m>f\d(z_0) = 0</m> are called <term>singular</term> and do not correspond to points of local conformality.</p>

        <p>Much of the behavior of analytic functions should be thought about in small neighborhoods around points. The next theorem is one that you learn in first year calculus and describes the relationship between the derivative of a function and the derivative of its inverse (when that inverse exists). Analytic functions away from singular points are <em>locally invertible</em>.</p>

        <theorem><title>Inverse function theorem</title>
            <p>Let <m>f:A \to \C</m> be analytic and <m>f\d(z_0) \neq 0</m> for <m>z_0 \in A</m>. Then there exists a neighborhood <m>U</m> of <m>z_0</m> and a neighborhood <m>V</m> of <m>f(z_0)</m> so that
            <ol>
                <li>the restriction <m>f:U \to V</m> is a bijection,</li>
                <li><m>f\inv:V \to U</m> is analytic,</li>
                <li>and 
                    <me> \frac{d}{dw} f\inv(w) = \frac{1}{f\d(z)} </me>
                    where <m>w = f(z)</m>.
                </li>
            </ol>
            </p>
        </theorem>

        <p>The inverse function theorem will let us make more connections between conformal maps and their inverses.</p>

        <proposition>
            <p>If a map <m>f:A \to B</m> is conformal and bijective, then <m>f\inv:B \to A</m> is conformal and bijective.</p>
        </proposition>
        <proof>
            <p>Because <m>f</m> is bijective, <m>f\inv</m> exists. Because <m>f</m> is conformal, for any <m>z \in A</m>, we must have <m>f\d(z) \neq 0</m>. Then the inverse function theorem gives that <m>f\inv</m> is analytic and
            <me> \frac{d}{dw} f\inv(w) = \frac{1}{f\d(z)} \neq 0, </me>
            and so <m>f\inv</m> is also conformal.</p>
        </proof>

        <proposition>
            <p>If <m>f:A \to B</m> is conformal and bijective and <m>g: B \to C</m> is conformal and bijective, then <m> g\circ f</m> is conformal and bijective.</p>
        </proposition>
        <proof>
            <p>This is an immediate consequence of the chain rule.</p>
        </proof>

        <p>Because conformality is preserved by inverses and composition, we have the structure necessary to impose ideas from algebra on the family of conformal maps if we can make the functions compatible. An <term>automorphism</term> is a bijection from a set onto itself.</p>

        <theorem>
            <p>The set of bijective conformal maps from a domain <m>A</m> to itself (that is, the set of conformal automorphisms of <m>A</m>) is a group, where the group operation is composition of functions.</p>
        </theorem>

        <p>As part of our study of conformal maps, we're going to be looking a special family of automorphisms defined on the unit disk <m>\D</m>, but that's for later!</p>

        <p>A typical use of bijective conformal maps is to change problems in one domain to problems in a different domain. It might not be obvious why, but frequently we can use tools in one domain that might not be available in another. Because bijective conformal maps preserve information about paths, solving a problem in one domain can be easily extended to a solution in a conformal relative.</p>

        <definition>
            <p> Two domains <m>A, B \subset \C</m> are called <term>conformally equivalent</term> if there is a bijective conformal map <m>f: A \to B</m>.</p>
        </definition>

        <theorem>
            <p>Let <m>A</m> be a simply connected domain that isn't all of <m>\C</m>. Then there exists a bijective conformal map <m>f: A \to \D</m>. Futher, for any fixed <m>z_0 \in A</m>, we can find <m>f</m> so that <m>f(z_0) = 0</m> and <m>f\d(z_0) > 0</m>. With these conditions, the map <m>f</m> is unique.</p>
        </theorem>

        <p>There is a pretty easy but very striking corollary.</p>

        <corollary> 
            <p>Any two simply connected domains, neither of which is all of <m>\C</m>, are conformally equivalent.</p>
        </corollary>

        <p>Of course there are some annoyances here: we have no clue how to actually find the maps! We also don't know what happens at the boundary of the domains in the general case. Our next steps will be to address these questions.</p>
    </section>
    </chapter>





</book>

</pretext>
